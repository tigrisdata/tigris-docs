# Consistency Model

There are only a few things you need to know about TigrisDB's consistency model.

The first is that all operations run within a transaction by default. This is important because it means that you never have to reason about how your transactions will interact with non-transactional code.

The second is that transactions are interactive--meaning you can explicitly start and terminate them in your application, just like you would with a traditional single node RDMS like Postgres. There are no restrictions on which operations can be performed within a transaction. You can combine writes, reads, updates, and deletes for any set of collections arbitrarily within a single transaction. There are some limitations on the size and duration of the transactions themselves, but most application will never encounter these limits.

Finally, all transactions execute with the guarantee of strict serializability, the strong possible consistency model. If you're not familiar with the term strict serializability, you can think about it this way: Regardless of the quantity, concurrency, complexity, and heterogeneity of the transactions generated by your application, TigrisDB guarantees that they will all execute (or abort due to conflicts) **as if** you sat down and typed them all out by hand and executed them one-by-one. In other words, you can write all of your code as if each transaction you create and execute is running in a single-threaded environment, and Tigris guarantees you won't encounter any surprises.

That's it. No ifs, ands, or buts. You don't need to reason about nebulous concepts like read and write concerns, whether or not the node you're querying is a read-replica with a stale view of the world, or how the transction you wrote running at isolation level read comitted will interact with a concurrent transaction written running at isolation level repeatable read.

That said, TigrisDB isn't magic. If your application creates too many transactions that read and write the same documents, some of your transactions will have conflicts and fail. That said, this problem is usually solveable with proper data modeling.
