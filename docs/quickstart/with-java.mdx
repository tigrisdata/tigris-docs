# Quickstart: Java

:::tip
‚è± This guide should require less than 5 minutes

:::

With a few quick steps, the following guide will get you up and running with
a RESTful web application that uses Tigris as the backend.

## Prerequisites

All you'll need is any computer running macOS or Linux, with the following
installed:

- [Docker](https://docs.docker.com/get-docker/)
- [JDK version](http://www.oracle.com/technetwork/java/javase/downloads/index.html) 8, 11 or 17
- [Apache maven](https://maven.apache.org/install.html)

## Build a RESTful Application

We will build an application that will accept HTTP requests to store and
retrieve data in the Tigris backend. This is a simplified implementation of
an e-commerce use case.

Now let's get started locally with Tigris.

### Startup Tigris locally via Docker

The first step is to install the CLI

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<Tabs>
<TabItem value="macOS" label="macOS">

```shell
curl -sSL https://tigris.dev/cli-macos | sudo tar -xz -C /usr/local/bin
```

</TabItem>
<TabItem value="Linux" label="Linux">

```shell
curl -sSL https://tigris.dev/cli-linux | sudo tar -xz -C /usr/local/bin
```

</TabItem>
</Tabs>

Next we start up Tigris locally using the _tigris_ cli

```shell
tigris local up
```

Once this command has completed, Tigris server will be available on port
`8081`.

### Download the starter project

Fire up the terminal and use the following command to download the starter
project that we've put together for this guide

```shell
mkdir tigris-starter && curl -sSL https://tigris.dev/java-starter  | tar -xz --strip=1 -C tigris-starter
```

### Build the project

From your terminal move into the starter project directory and build the
project

```shell
cd tigris-starter
mvn clean install
```

### Run the application

Next run the application from your favorite IDE. An example using **IntelliJ
IDEA** is shown below

![intellij_launcher image](/img/screenshots/intellij_launcher.png)

:::info
A successful launch of the application will end with the log entry

```shell
[main] INFO  c.t.starter.spring.TigrisInitializer - Finished initializing Tigris
```

:::

Congratulations, you just wrote a REST service which uses Tigris as the
backend.

Try out the REST API at
[http://localhost:8080/swagger.html](http://localhost:8080/swagger.html)

![swagger_openapi_image](/img/screenshots/java_starter_openapi.png)
![swagger_openapi_image](/img/screenshots/java_starter_schemas.png)

Let's create a user and a product.

**Create a User**

```shell
curl -X 'POST' \
  'http://localhost:8080/users/create' \
  -H 'Content-Type: application/json' \
  -d '{
  "id": 1,
  "name": "Jania McGrory",
  "balance": 6045.7
}'
```

**Create a Product**

```shell
curl -X 'POST' \
  'http://localhost:8080/products/create' \
  -H 'Content-Type: application/json' \
  -d '{
  "id": 1,
  "name": "Vanilla Beans",
  "quantity": 6358,
  "price": 4.39
}'
```

These newly added User and Product documents were persisted in the Tigris
backend.

### Extend the application

Now let's set up a HTTP handler that will leverage Tigris to insert data
into the _orders_ collection while updating the data in the _users_ and
_products_ collections.

:::info
One of the main features of Tigris is the ability to perform ACID
transactions. We will perform the insert and update operations in a
transaction ensuring that the collections are consistently updated.

:::

Open the project in your favorite IDE and add the following to
`com.tigrisdata.starter.controller.OrderController`

**Additional Imports**

```java title="OrderController.java"
import com.tigrisdata.db.client.TransactionOptions;
import com.tigrisdata.db.client.TransactionSession;
import com.tigrisdata.db.client.TransactionTigrisCollection;
import com.tigrisdata.db.client.UpdateFields;
import com.tigrisdata.starter.collections.Product;
import com.tigrisdata.starter.collections.User;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import java.util.Collections;
```

**HTTP handler**

```java title="OrderController.java"
@PostMapping("{user_id}/{product_id}/{qty}")
public ResponseEntity<String> purchase(
    @RequestParam("user_id") int userId,
    @RequestParam("product_id") int productId,
    @RequestParam("qty") int quantity)
    throws TigrisException {

  // Begin the transaction and perform all operations below in the context of
  // this transaction
  TransactionSession transactionSession =
      tigrisStarterDatabase.beginTransaction(new TransactionOptions());

  try {
    // retrieve session aware collection
    TransactionTigrisCollection<User> userCollection =
        transactionSession.getCollection(User.class);
    TransactionTigrisCollection<Product> productCollection =
        transactionSession.getCollection(Product.class);
    TransactionTigrisCollection<Order> orderCollection =
        transactionSession.getCollection(Order.class);

    // read the user and product documents
    User user = userCollection.readOne(Filters.eq("id", userId)).get();
    Product product = productCollection.readOne(Filters.eq("id", productId)).get();

    // ensure that a user is never allowed to purchase products worth more than
    // their available balance, and that we never create orders that exceed the
    // amount of available product
    if (product.getQuantity() >= quantity && product.getPrice() * quantity <= user.getBalance()) {
      double orderTotal = product.getPrice() * quantity;
      double newUserBalance = user.getBalance() - orderTotal;
      int newProductQuantity = product.getQuantity() - quantity;
      userCollection.update(
          Filters.eq("id", userId),
          UpdateFields.newBuilder().set("balance", newUserBalance).build());

      productCollection.update(
          Filters.eq("id", productId),
          UpdateFields.newBuilder().set("quantity", newProductQuantity).build());

      orderCollection.insert(
          new Order(
              orderIdSequence.incrementAndGet(),
              userId,
              orderTotal,
              Collections.singletonList(new Order.ProductItem(productId, quantity))));

      // commit the transaction to persist all the changes
      transactionSession.commit();
      return ResponseEntity.status(HttpStatus.OK).body("Purchased successfully");
    } else {
      transactionSession.rollback();
      return ResponseEntity.status(HttpStatus.PRECONDITION_FAILED).body("Not enough balance");
    }
  } catch (Exception ex) {
    transactionSession.rollback();
    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Failed to shop");
  }
}
```

Run the application again and use the newly added HTTP endpoint to create an
order.

**Create an Order**

```shell
curl -X 'POST' 'http://localhost:8080/order/1/1/20
```

## Understanding what just happened

The starter project includes the Java model classes corresponding to the
three collections _users_, _products_ and _orders_ located in the Java
package `com.tigrisdata.starter.collections`.

When you launched the application, code located in
`com.tigrisdata.starter.spring.TigrisInitializer#run` created the database
and registered the schema with the Tigris backend based on the three collection
models.

You wrote a new HTTP handler that used Tigris' transaction feature. The
transaction involved reading data, validating that certain conditions around
the product quantity and user's balance are met, and finally inserting a new
order together with updating the users and products collections.
