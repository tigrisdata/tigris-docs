# Quickstart: Go

Tigris offers simple and intuitive APIs to make it easy for you get started
with any data architecture needs!

Setting up the database is instantaneous, as well - no need for tedious
configuration. You define the data model as part of the application code,
which then drives the database infrastructure without you having to
configure and provision database resources.

Furthermore, you can continue using your preferred programming language when
working with Tigris. There is no new database query language to learn!

The following guide will get you up and running with Go.

:::tip
‚è± This guide should require less than 5 minutes

:::

First let's review what you need to get going.

## Prerequisites

All you'll need is any computer running macOS or Linux, with the following
installed:

- [Docker](https://docs.docker.com/get-docker/)
- [Golang 1.18 or newer](https://go.dev/dl/)

## Working locally

First let's get started with Tigris locally.

### Startup Tigris locally via Docker

The first step is to install the CLI

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<Tabs>
<TabItem value="macOS" label="macOS">

```shell
curl -sSL https://tigris.dev/cli-macos | sudo tar -xz -C /usr/local/bin
```

</TabItem>
<TabItem value="Linux" label="Linux">

```shell
curl -sSL https://tigris.dev/cli-linux | sudo tar -xz -C /usr/local/bin
```

</TabItem>
</Tabs>

Next we start up Tigris locally using the _tigris_ cli

```shell
tigris local up
```

Once this command has completed, Tigris server will be available on port
`8081`.

## Install the client library

```shell
go get -u github.com/tigrisdata/tigris-client-go@latest
```

## Quickstart

```go title=main.go
package main

import (
	"context"
	"time"

	"github.com/tigrisdata/tigris-client-go/config"
	"github.com/tigrisdata/tigris-client-go/fields"
	"github.com/tigrisdata/tigris-client-go/filter"
	"github.com/tigrisdata/tigris-client-go/tigris"
)

type User struct {
	Id      int `tigris:"primary_key"`
	Name    string
	Balance float64
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
	defer cancel()

	// Connect to the Tigris backend, create the database and collection if they don't exist,
	// otherwise update the schema of the collection if it already exists
	db, err := tigris.OpenDatabase(ctx, &config.Database{Driver: config.Driver{URL: "localhost:8081"}},
		"hello_db", &User{})
	if err != nil {
		panic(err)
	}

	// Get the collection object, all the CRUD operations on the collection will be performed
	// through this collection object
	users := tigris.GetCollection[User](db)

	// Insert or replace user
	users.InsertOrReplace(ctx,
		&User{Id: 1, Name: "Jania McGrory", Balance: 6045.7},
		&User{Id: 2, Name: "Bunny Instone", Balance: 2948.87})

	// Read
	var user *User
	user, err = users.ReadOne(ctx, filter.Eq("Id", 1)) // find user with Id 1
	if err != nil {
		panic(err)
	}

	// Update - update user's name
	users.Update(ctx, filter.Eq("Id", 1), fields.Set("Name", "Jania McGrover"))

	// Global, ACID Transaction with strict serializability using
	// optimistic concurrency control
	// Transfer between users
	db.Tx(ctx, func(txCtx context.Context) error {
		var userOne *User
		if userOne, err = users.ReadOne(txCtx, filter.Eq("Id", 1)); err != nil {
			return err
		}

		var userTwo *User
		if userTwo, err = users.ReadOne(txCtx, filter.Eq("Id", 2)); err != nil {
			return err
		}

		if _, err = users.Update(txCtx, filter.Eq("Id", 1),
			fields.Set("Balance", userOne.Balance-100)); err != nil {
			return err
		}
		if _, err = users.Update(txCtx, filter.Eq("Id", 2),
			fields.Set("Balance", userTwo.Balance+100)); err != nil {
			return err
		}

		return nil
	})

	// Delete - delete users with Id 1 or 2
	users.Delete(ctx, filter.Or(filter.Eq("Id", 1), filter.Eq("Id", 2)))
}
```
