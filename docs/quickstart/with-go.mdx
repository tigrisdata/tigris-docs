# Quickstart: Go

The following guide will get you up and running with Go.

:::tip
Define the data model in the application code, which sets up the database
instantaneously. Easily evolve the data model as your application evolves
without worrying about breaking a rigid schema.

Quickly add data and easily retrieve or edit that data through simple and
intuitive APIs. Continue using your preferred programming language, there is
no new database query language to learn.

:::

First let's review what you need to get going.

## Prerequisites

All you'll need is any computer running macOS or Linux, with the following
installed:

- [Docker](https://docs.docker.com/get-docker/)
- [Golang 1.18 or newer](https://go.dev/dl/)

Next, let's get started with Tigris locally.

## Startup Tigris locally via Docker

import StartupLocally from "../includes/_startup_tigris_locally.mdx";

<StartupLocally />

## Install the client library

```shell
go get -u github.com/tigrisdata/tigris-client-go@latest
```

## Quickstart

```go title=main.go
package main

import (
	"context"
	"fmt"
	"time"

	"github.com/tigrisdata/tigris-client-go/config"
	"github.com/tigrisdata/tigris-client-go/fields"
	"github.com/tigrisdata/tigris-client-go/filter"
	"github.com/tigrisdata/tigris-client-go/tigris"
)

// User is a declaration of the model for the collection
type User struct {
	tigris.Model
	Name    string
	Balance float64
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
	defer cancel()

	// Connect to the Tigris backend, create the database and collection if they don't exist,
	// otherwise update the schema of the collection if it already exists
	db, err := tigris.OpenDatabase(ctx, &config.Database{Driver: config.Driver{URL: "localhost:8081"}},
		"hello_db", &User{})
	if err != nil {
		panic(err)
	}

	// Get the collection object, all the CRUD operations on the collection will be performed
	// through this collection object
	users := tigris.GetCollection[User](db)

	// Insert
	userJ := User{Name: "Jania McGrory", Balance: 6045.7}
	userB := User{Name: "Bunny Instone", Balance: 2948.87}
	users.Insert(ctx, &userJ, &userB)

	// Read
	var user *User
	user, err = users.ReadOne(ctx, filter.Eq("ID", userJ.ID)) // find user with primary key field
	if err != nil {
		panic(err)
	}
	fmt.Println(user)

	user, err = users.ReadOne(ctx, filter.Eq("Name", "Jania McGrory")) // find user with Name Jania McGrory
	if err != nil {
		panic(err)
	}
	fmt.Println(user)

	// Update - update user's name
	users.Update(ctx, filter.Eq("ID", userJ.ID), fields.Set("Name", "Jania McGrover"))

	// Transaction - transfer balance between users
	db.Tx(ctx, func(txCtx context.Context) error {
		// update their balance
		if _, err = users.Update(txCtx, filter.Eq("ID", userJ.ID),
			fields.Set("Balance", userJ.Balance-100)); err != nil {
			return err
		}
		if _, err = users.Update(txCtx, filter.Eq("ID", userB.ID),
			fields.Set("Balance", userB.Balance+100)); err != nil {
			return err
		}

		return nil
	})

	// Delete - delete users with IDs 1 or 2
	users.Delete(ctx, filter.Or(filter.Eq("ID", userJ.ID), filter.Eq("ID", userB.ID)))

	// Drop the database and its collections
	db.Drop(ctx)
}
```
