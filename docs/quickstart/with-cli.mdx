# Quickstart: CLI

The following guide will get you up and running using the CLI.

:::tip
‚è± This guide should require less than 5 minutes

:::

First let's review what you need to get going.

## Prerequisites

All you'll need is any computer running macOS or Linux, with
[docker](https://docs.docker.com/get-docker/) installed.

## Working locally

Now let's get started locally with Tigris in three easy steps:

### Startup Tigris locally via Docker

The first step is to install the CLI

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<Tabs>
<TabItem value="macOS" label="macOS">

```shell
curl -sSL https://tigris.dev/cli-macos | sudo tar -xz -C /usr/local/bin
```

</TabItem>
<TabItem value="Linux" label="Linux">

```shell
curl -sSL https://tigris.dev/cli-linux | sudo tar -xz -C /usr/local/bin
```

</TabItem>
</Tabs>

Next we start up Tigris locally using the _tigris_ cli

```shell
tigris local up
```

Once this command has completed, Tigris server will be available on port
`8081`.

### Create sample schema

For this quickstart we will model a simple ecommerce app. The data would be
stored in three collections _products_, _users_ and _orders_.

Let's use the CLI to generate the sample schema and create the three
collections in the database named _sampledb_.

```shell
tigris generate sample-schema --create
```

The schema of the collections created can be fetched as follows

```shell
tigris describe collection sampledb orders
```

### Insert and read data

The following example will insert data into the _users_ and _products_
collections and then read it back.

One of the main features of Tigris is the ability to perform ACID
transactions. We will perform a transaction that involves inserting and
updating documents in the _orders_, _users_ and _products_ collections.

Now lets fire up the CLI and use the Tigris APIs to perform CRUD operations on
the data.

#### Insert some data into the user and product collections

```shell
tigris insert sampledb users \
'[
    {"id": 1, "name": "Jania McGrory", "balance": 6045.7},
    {"id": 2, "name": "Bunny Instone", "balance": 2948.87}
]'
```

```shell
tigris insert sampledb products \
'[
    {"id": 1, "name": "Vanilla Beans", "quantity": 6358, "price": 4.39},
    {"id": 2, "name": "Cheese - Provolone", "quantity": 5726, "price": 16.74},
    {"id": 3, "name": "Cake - Box Window 10x10x2.5", "quantity": 5514, "price": 36.4}
]'
```

#### Read the data that was inserted by the Primary key field

```shell
tigris read sampledb users '{"id": 1}'
```

```shell
tigris read sampledb products '{"id": 3}'
```

#### Read the data that was inserted by any field in the schema

```shell
tigris read sampledb users '{"name": "Jania McGrory"}'
```

```shell
tigris read sampledb products '{"name": "Vanilla Beans"}'
```

#### Perform a transaction that modifies all three collections

```shell
tigris transact sampledb \
'[
  {
    "insert": {
      "collection": "orders",
      "documents": [{
          "id": 1, "user_id": 1, "order_total": 53.89, "products": [{"id": 1, "quantity": 1}]
        }]
    }
  },
  {
    "update": {
      "collection": "users", "fields": {"$set": {"balance": 5991.81}}, "filter": {"id": 1}
    }
  },
  {
    "update": {
      "collection": "products", "fields": {"$set": {"quantity": 6357}}, "filter": {"id": 1}
    }
  }
]'
```

The transaction we just executed updates three different collections in a
single atomic transaction, all while running at an isolation level of strict
serializability.

:::info
Note that because we're using the CLI, the transaction doesn't appear to be
interactive. When using the Tigris client library the transaction would be
interactive, and we could enforce constraints within our application. Such as,
ensuring that the user has enough balance or that there is enough available
product.

See the [Go quick start](with-go.mdx) section for an example of how we can
leverage Tigris' transactions.

:::
