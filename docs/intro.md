---
id: intro
slug: /
---

# Introduction

## What is TigrisDB?

[TigrisDB](https://github.com/tigrisdata/tigrisdb) is an open-source, zero-ops, globally
distributed NoSQL database for real-time websites and apps.

We are fully committed to open source and embrace the open exchange of
information, collaborative development and transparency.

TigrisDB is permissively licensed under the terms of the
[Apache License v2.0](http://www.apache.org/licenses/LICENSE-2.0)

## How is TigrisDB different from other databases?

There are a lot of things that distinguish Tigris from other databases, but the primary one is a relentless focus on a seamless user experience. Specifically, TigrisDB prioritizes reliability and correctness over everything else. Performance is important to us too, but we care more about building a database that never wakes you up in the middle of the night than winning synthetic benchmarks.

### Old Meets New: Built On a Strong Foundation

The first thing that distinguishes TigrisDB from other modern distributed databases is that it's built on top of one of the most reliable and battle-tested storage technologies ever created: FoundationDB (FDB). The FoundationDB [documentation](https://apple.github.io/foundationdb/testing.html) and [paper](https://www.foundationdb.org/files/fdb-paper.pdf) go into more detail, but the short of it is that FDB was designed from the ground up around the idea of continuous "simulation testing". While most other distributed databases might get subjected to a proper [Jepsen](https://jepsen.io/analyses) test once or twice in their entire lifetime, FoundationDB is subjected to significantly more strenous testing every night. Suffice it to say that there is a reason companies like Apple and Snowflake use FoundationDB to store their most critical data.

### Consistency Model

There are only a few things you need to know about TigrisDB's consistency model.

The first is that all operations run within a transaction by default. This is important because it means that you never have to reason about how your transactions will interact with non-transactional code.

The second is that transactions are interactive--meaning you can explicitly start and terminate them in your application, just like you would with a traditional single node RDMS like Postgres. There are no restrictions on which operations can be performed within a transaction. You can combine writes, reads, updates, and deletes for any set of collections arbitrarily within a single transaction. There are some limitations on the size and duration of the transactions themselves, but most application will never encounter these limits.

Finally, all transactions execute with the guarantee of strict serializability, the strong possible consistency model. If you're not familiar with the term strict serializability, you can think about it this way: Regardless of the quantity, concurrency, complexity, and heterogeneity of the transactions generated by your application, TigrisDB guarantees that they will all execute (or abort due to conflicts) **as if** you sat down and typed them all out by hand and executed them one-by-one. In other words, you can write all of your code as if each transaction you create and execute is running in a single-threaded environment, and Tigris guarantees you won't encounter any surprises.

That's it. No ifs, ands, or buts. You don't need to reason about nebulous concepts like read and write concerns, whether or not the node you're querying is a read-replica with a stale view of the world, or how the transction you wrote running at isolation level read comitted will interact with a concurrent transaction written running at isolation level repeatable read.

That said, TigrisDB isn't magic. If your application creates too many transactions that read and write the same documents, some of your transactions will have conflicts and fail. That said, this problem is usually solveable with proper data modeling.

### More Than Just a Database

